[section Introduction]

Writing iterators is suprisingly hard.  There are a lot of things that can
subtly go wrong.  It is also very tedious, which of course consequently makes
it error-prone.

As a quick example, let's say that we wanted to make a random access iterator
that represents a string of arbitrary length constructed by repeating a
shorter string.  Let's call this iterator `repeated_chars_iterator`.  Here it
is in action:

[repeated_chars_iterator_usage]

There's nothing in the standard library that gets us that kind of behavior, so
we have to write it.  This library seeks to turn what we write from this:

    struct repeated_chars_iterator
    {
        using value_type = char;
        using difference_type = std::ptrdiff_t;
        using pointer = char const *;
        using reference = char const;
        using iterator_category = std::random_access_iterator_tag;

        constexpr repeated_chars_iterator() noexcept :
            first_(nullptr),
            size_(0),
            n_(0)
        {}
        constexpr repeated_chars_iterator(
            char const * first,
            difference_type size,
            difference_type n) noexcept :
            first_(first),
            size_(size),
            n_(n)
        {}

        constexpr reference operator*() const noexcept
        {
            return first_[n_ % size_];
        }

        constexpr value_type operator[](difference_type n) const noexcept
        {
            return first_[(n_ + n) % size_];
        }

        BOOST_TEXT_CXX14_CONSTEXPR repeated_chars_iterator &
        operator++() noexcept
        {
            ++n_;
            return *this;
        }
        BOOST_TEXT_CXX14_CONSTEXPR repeated_chars_iterator
        operator++(int)noexcept
        {
            repeated_chars_iterator retval = *this;
            ++*this;
            return retval;
        }
        BOOST_TEXT_CXX14_CONSTEXPR repeated_chars_iterator &
        operator+=(difference_type n) noexcept
        {
            n_ += n;
            return *this;
        }

        BOOST_TEXT_CXX14_CONSTEXPR repeated_chars_iterator &
        operator--() noexcept
        {
            --n_;
            return *this;
        }
        BOOST_TEXT_CXX14_CONSTEXPR repeated_chars_iterator
        operator--(int)noexcept
        {
            repeated_chars_iterator retval = *this;
            --*this;
            return retval;
        }
        BOOST_TEXT_CXX14_CONSTEXPR repeated_chars_iterator &
        operator-=(difference_type n) noexcept
        {
            n_ -= n;
            return *this;
        }

        friend constexpr bool operator==(
            repeated_chars_iterator lhs, repeated_chars_iterator rhs) noexcept
        {
            return lhs.first_ == rhs.first_ && lhs.n_ == rhs.n_;
        }
        friend constexpr bool operator!=(
            repeated_chars_iterator lhs, repeated_chars_iterator rhs) noexcept
        {
            return !(lhs == rhs);
        }
        friend constexpr bool operator<(
            repeated_chars_iterator lhs, repeated_chars_iterator rhs) noexcept
        {
            return lhs.first_ == rhs.first_ && lhs.n_ < rhs.n_;
        }
        friend constexpr bool operator<=(
            repeated_chars_iterator lhs, repeated_chars_iterator rhs) noexcept
        {
            return lhs == rhs || lhs < rhs;
        }
        friend constexpr bool operator>(
            repeated_chars_iterator lhs, repeated_chars_iterator rhs) noexcept
        {
            return rhs < lhs;
        }
        friend constexpr bool operator>=(
            repeated_chars_iterator lhs, repeated_chars_iterator rhs) noexcept
        {
            return lhs <= rhs;
        }

        friend BOOST_TEXT_CXX14_CONSTEXPR repeated_chars_iterator
        operator+(repeated_chars_iterator lhs, difference_type rhs) noexcept
        {
            return lhs += rhs;
        }
        friend BOOST_TEXT_CXX14_CONSTEXPR repeated_chars_iterator
        operator+(difference_type lhs, repeated_chars_iterator rhs) noexcept
        {
            return rhs += lhs;
        }
        friend BOOST_TEXT_CXX14_CONSTEXPR repeated_chars_iterator
        operator-(repeated_chars_iterator lhs, difference_type rhs) noexcept
        {
            return lhs -= rhs;
        }
        friend BOOST_TEXT_CXX14_CONSTEXPR repeated_chars_iterator
        operator-(difference_type lhs, repeated_chars_iterator rhs) noexcept
        {
            return rhs -= lhs;
        }
        friend constexpr difference_type operator-(
            repeated_chars_iterator lhs, repeated_chars_iterator rhs) noexcept
        {
            return lhs.n_ - rhs.n_;
        }

    private:
        char const * first_;
        difference_type size_;
        difference_type n_;
    };

(that's a lot of code!) into this:

[repeated_chars_iterator]

Ah, that's better.  Both of these definitions for `repeated_chars_iterator`
have the same semantics and performance profile.  It's just a lot less code to
write the second one, and writing the second one is more novice-friendly.

[note _Facade_'s `iterator_facade` implements iterators that model the C++20
iterator concepts.]

[endsect]

[section A Bit of Background]

_Iterator_ is a library that is already in Boost, and it has been around for a
long time.

However, it was attempting to solve a lot of problems related to iterators,
not just how to write them from scratch.  It is also not easy to modernize it
for use in C++11 and later.  Specifically:

- _Iterator_ contains a large number of iterator adaptors; those have since
  been rendered moot by C++20 ranges.

- _Iterator_'s `iterator_facade` template is not limited just to the existing
  standard C++ iterator categories; that was an experiment that never landed
  in standard C++, so it adds needless complexity.

- _Iterator_'s `iterator_facade` was written against C++98, so it is not
  `constexpr`- and `noexcept`-friendly.

- _Iterator_'s `iterator_facade` does not support proxy iterators, which are
  fully supported by the C++20 iterator concepts.

- There is opportunity to reduce the amount of code the user must write in
  order to use `iterator_facade`.

For these reasons, it seems more appropriate to introduce a new Boost library
than to try and address the shortcomings of _Iterator_'s `iterator_facade`
template directly.

[endsect]
