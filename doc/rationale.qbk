[section Rationale]

[heading There Are Minimal Derived-Type Contraints]

This is the constraint on the `Derived` template parameter to _iter_iface_,
_view_iface_ and _cont_iface_:

    std::enable_if_t<
        std::is_class<Derived>::value &&
        std::is_same<Derived, std::remove_cv_t<Derived>>::value>

This prevents instantiating an interface template with an `int`, a `const`
type, a reference type, etc.

There are not more constraints (for instance, that _view_iface_ is given a
`Derived` template parameter for a type that has a `begin()` and `end()`),
because `Derived` is an incomplete type within each *`_interface` template.

[heading Using a Special Access-Granting `struct`]

The interface templates rely mostly on public members provided by their
`Derived` template parameter.  However, _iter_iface_ requires you to supply
`base_reference()` functions if you want it to act like an adaptor.  Since at
least the non-`const` overload provides a non-`const` lvalue reference to one
of your types data members, it will break the encapsulation of many types to
leave `base_reference()` a public member.  To allow users to keep these
overloads private, _access_ exists.

[heading _iter_iface_ Can Act Like an Adaptor, And the Other Interface Templates Can't]

There wouldn't be much point in adding this functionality to _view_iface_,
because it only uses the `begin()` and `end()` of the `Derived` type anyway.

For _cont_iface_ it also does not make much sense.  Consider how many
container adaptors you've written.  That's a use case that does not come up
often.

[heading _iter_iface_ Takes a Lot of Template Parameters, And the Other Interface Templates Don't]

_iter_iface_ does in fact take a lot of template parameters.  However, it
usually only takes 3: the `Derived` type, the iterator category, and the
iterator's `value_type`.

When you make a proxy iterator, you typically use the _proxy_iter_iface_
alias, and you again only need the same template parameters.  Though you can
opt into more template parameters, the rest are seldom necessary.

By contrast, the _view_iface_ and _cont_iface_ templates have very few
template parameters.  For _view_iface_, this is because there are no member
typedefs in the `view` concept.  For _cont_iface_, it was deemed ridiculous to
create a template whose purpose is to reduce code size, which takes 14
template parameters.]

[heading _cont_iface_ Does not Support Associative or Unordered Associative Containers]

That's right.  Associative containers have an interface that assumes that they
are node-based containers.  On modern hardware, node-based containers are not
very efficient, and I don't want to encourage people to write more of them.
Unordered associative containers have an interface that precludes open
addressing.  I don't want to encourage more of that either.

[endsect]
